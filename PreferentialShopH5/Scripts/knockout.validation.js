(function (factory) { if (typeof require === "function" && typeof exports === "object" && typeof module === "object") { factory(require("knockout"), exports) } else if (typeof define === "function" && define["amd"]) { define(["knockout", "exports"], factory) } else { factory(ko, ko.validation = {}) } }(function (ko, exports) { if (typeof (ko) === undefined) { throw 'Knockout is required, please ensure it is loaded before loading this validation plug-in' } ko.validation = exports; var kv = ko.validation, koUtils = ko.utils, unwrap = koUtils.unwrapObservable, forEach = koUtils.arrayForEach, extend = koUtils.extend; var defaults = { registerExtenders: true, messagesOnModified: true, errorsAsTitle: true, errorsAsTitleOnModified: false, messageTemplate: null, insertMessages: true, parseInputAttributes: false, writeInputAttributes: false, decorateInputElement: false, decorateElementOnModified: true, errorClass: null, errorElementClass: 'validationElement', errorMessageClass: 'validationMessage', allowHtmlMessages: false, grouping: { deep: false, observable: true, live: false }, validate: {} }; var configuration = extend({}, defaults); configuration.html5Attributes = ['required', 'pattern', 'min', 'max', 'step']; configuration.html5InputTypes = ['email', 'number', 'date']; configuration.reset = function () { extend(configuration, defaults) }; kv.configuration = configuration; kv.utils = (function () { var seedId = new Date().getTime(); var domData = {}; var domDataKey = '__ko_validation__'; return { isArray: function (o) { return o.isArray || Object.prototype.toString.call(o) === '[object Array]' }, isObject: function (o) { return o !== null && typeof o === 'object' }, isObservableArray: function (instance) { return !!instance && typeof instance["remove"] === "function" && typeof instance["removeAll"] === "function" && typeof instance["destroy"] === "function" && typeof instance["destroyAll"] === "function" && typeof instance["indexOf"] === "function" && typeof instance["replace"] === "function" }, values: function (o) { var r = []; for (var i in o) { if (o.hasOwnProperty(i)) { r.push(o[i]) } } return r }, getValue: function (o) { return (typeof o === 'function' ? o() : o) }, hasAttribute: function (node, attr) { return node.getAttribute(attr) !== null }, getAttribute: function (element, attr) { return element.getAttribute(attr) }, setAttribute: function (element, attr, value) { return element.setAttribute(attr, value) }, isValidatable: function (o) { return !!(o && o.rules && o.isValid && o.isModified) }, insertAfter: function (node, newNode) { node.parentNode.insertBefore(newNode, node.nextSibling) }, newId: function () { return seedId += 1 }, getConfigOptions: function (element) { var options = kv.utils.contextFor(element); return options || kv.configuration }, setDomData: function (node, data) { var key = node[domDataKey]; if (!key) { node[domDataKey] = key = kv.utils.newId() } domData[key] = data }, getDomData: function (node) { var key = node[domDataKey]; if (!key) { return undefined } return domData[key] }, contextFor: function (node) { switch (node.nodeType) { case 1: case 8: var context = kv.utils.getDomData(node); if (context) { return context } if (node.parentNode) { return kv.utils.contextFor(node.parentNode) } break } return undefined }, isEmptyVal: function (val) { if (val === undefined) { return true } if (val === null) { return true } if (val === "") { return true } }, getOriginalElementTitle: function (element) { var savedOriginalTitle = kv.utils.getAttribute(element, 'data-orig-title'), currentTitle = element.title, hasSavedOriginalTitle = kv.utils.hasAttribute(element, 'data-orig-title'); return hasSavedOriginalTitle ? savedOriginalTitle : currentTitle }, async: function (expr) { if (window.setImmediate) { window.setImmediate(expr) } else { window.setTimeout(expr, 0) } }, forEach: function (object, callback) { if (kv.utils.isArray(object)) { return forEach(object, callback) } for (var prop in object) { if (object.hasOwnProperty(prop)) { callback(object[prop], prop) } } } } }()); var api = (function () { var isInitialized = 0, configuration = kv.configuration, utils = kv.utils; function cleanUpSubscriptions(context) { forEach(context.subscriptions, function (subscription) { subscription.dispose() }); context.subscriptions = [] } function dispose(context) { if (context.options.deep) { forEach(context.flagged, function (obj) { delete obj.__kv_traversed }); context.flagged.length = 0 } if (!context.options.live) { cleanUpSubscriptions(context) } } function runTraversal(obj, context) { context.validatables = []; cleanUpSubscriptions(context); traverseGraph(obj, context); dispose(context) } function traverseGraph(obj, context, level) { var objValues = [], val = obj.peek ? obj.peek() : obj; if (obj.__kv_traversed === true) { return } if (context.options.deep) { obj.__kv_traversed = true; context.flagged.push(obj) } level = (level !== undefined ? level : context.options.deep ? 1 : -1); if (ko.isObservable(obj)) { if (!obj.isValid) { obj.extend({ validatable: true }) } context.validatables.push(obj); if (context.options.live && utils.isObservableArray(obj)) { context.subscriptions.push(obj.subscribe(function () { context.graphMonitor.valueHasMutated() })) } } if (val && !val._destroy) { if (utils.isArray(val)) { objValues = val } else if (utils.isObject(val)) { objValues = utils.values(val) } } if (level !== 0) { utils.forEach(objValues, function (observable) { if (observable && !observable.nodeType) { traverseGraph(observable, context, level + 1) } }) } } function collectErrors(array) { var errors = []; forEach(array, function (observable) { if (!observable.isValid()) { errors.push(observable.error()) } }); return errors } return { init: function (options, force) { if (isInitialized > 0 && !force) { return } options = options || {}; options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass; options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass; extend(configuration, options); if (configuration.registerExtenders) { kv.registerExtenders() } isInitialized = 1 }, configure: function (options) { kv.init(options) }, reset: kv.configuration.reset, group: function group(obj, options) { options = extend(extend({}, configuration.grouping), options); var context = { options: options, graphMonitor: ko.observable(), flagged: [], subscriptions: [], validatables: [] }; var result = null; if (options.observable) { runTraversal(obj, context); result = ko.computed(function () { context.graphMonitor(); runTraversal(obj, context); return collectErrors(context.validatables) }) } else { result = function () { runTraversal(obj, context); return collectErrors(context.validatables) } } result.showAllMessages = function (show) { if (show === undefined) { show = true } result(); forEach(context.validatables, function (observable) { observable.isModified(show) }) }; obj.errors = result; obj.isValid = function () { return obj.errors().length === 0 }; obj.isAnyMessageShown = function () { var invalidAndModifiedPresent = false; result(); invalidAndModifiedPresent = !!koUtils.arrayFirst(context.validatables, function (observable) { return !observable.isValid() && observable.isModified() }); return invalidAndModifiedPresent }; return result }, formatMessage: function (message, params, observable) { if (typeof (message) === 'function') { return message(params, observable) } return message.replace(/\{0\}/gi, unwrap(params)) }, addRule: function (observable, rule) { observable.extend({ validatable: true }); observable.rules.push(rule); return observable }, addAnonymousRule: function (observable, ruleObj) { if (ruleObj['message'] === undefined) { ruleObj['message'] = 'Error' } if (ruleObj.onlyIf) { ruleObj.condition = ruleObj.onlyIf } kv.addRule(observable, ruleObj) }, addExtender: function (ruleName) { ko.extenders[ruleName] = function (observable, params) { if (params && (params.message || params.onlyIf)) { return kv.addRule(observable, { rule: ruleName, message: params.message, params: utils.isEmptyVal(params.params) ? true : params.params, condition: params.onlyIf }) } else { return kv.addRule(observable, { rule: ruleName, params: params }) } } }, registerExtenders: function () { if (configuration.registerExtenders) { for (var ruleName in kv.rules) { if (kv.rules.hasOwnProperty(ruleName)) { if (!ko.extenders[ruleName]) { kv.addExtender(ruleName) } } } } }, insertValidationMessage: function (element) { var span = document.createElement('SPAN'); span.className = utils.getConfigOptions(element).errorMessageClass; utils.insertAfter(element, span); return span }, parseInputValidationAttributes: function (element, valueAccessor) { forEach(kv.configuration.html5Attributes, function (attr) { if (utils.hasAttribute(element, attr)) { var params = element.getAttribute(attr) || true; if (attr === 'min' || attr === 'max') { var typeAttr = element.getAttribute('type'); if (typeof typeAttr === "undefined" || !typeAttr) { typeAttr = "text" } params = { typeAttr: typeAttr, value: params } } kv.addRule(valueAccessor(), { rule: attr, params: params }) } }); var currentType = element.getAttribute('type'); forEach(kv.configuration.html5InputTypes, function (type) { if (type === currentType) { kv.addRule(valueAccessor(), { rule: (type === 'date') ? 'dateISO' : type, params: true }) } }) }, writeInputValidationAttributes: function (element, valueAccessor) { var observable = valueAccessor(); if (!observable || !observable.rules) { return } var contexts = observable.rules(); forEach(kv.configuration.html5Attributes, function (attr) { var params; var ctx = koUtils.arrayFirst(contexts, function (ctx) { return ctx.rule.toLowerCase() === attr.toLowerCase() }); if (!ctx) { return } params = ctx.params; if (ctx.rule === "pattern") { if (ctx.params instanceof RegExp) { params = ctx.params.source; } } element.setAttribute(attr, params) }); contexts = null }, makeBindingHandlerValidatable: function (handlerName) { var init = ko.bindingHandlers[handlerName].init; ko.bindingHandlers[handlerName].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext); return ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) } }, setRules: function (target, definition) { var setRules = function (target, definition) { if (!target || !definition) { return } for (var prop in definition) { if (!definition.hasOwnProperty(prop)) { continue } var ruleDefinitions = definition[prop]; if (!target[prop]) { continue } var targetValue = target[prop], unwrappedTargetValue = unwrap(targetValue), rules = {}, nonRules = {}; for (var rule in ruleDefinitions) { if (!ruleDefinitions.hasOwnProperty(rule)) { continue } if (kv.rules[rule]) { rules[rule] = ruleDefinitions[rule] } else { nonRules[rule] = ruleDefinitions[rule] } } if (ko.isObservable(targetValue)) { targetValue.extend(rules) } if (unwrappedTargetValue && utils.isArray(unwrappedTargetValue)) { for (var i = 0; i < unwrappedTargetValue.length; i++) { setRules(unwrappedTargetValue[i], nonRules) } } else { setRules(unwrappedTargetValue, nonRules) } } }; setRules(target, definition) } } }()); extend(ko.validation, api); kv.rules = {}; kv.rules['required'] = { validator: function (val, required) { var stringTrimRegEx = /^\s+|\s+$/g, testVal; if (val === undefined || val === null) { return !required } testVal = val; if (typeof (val) === "string") { testVal = val.replace(stringTrimRegEx, '') } if (!required) { return true } return ((testVal + '').length > 0) }, message: '*' }; function minMaxValidatorFactory(validatorName) { var isMaxValidation = validatorName === "max"; return function (val, options) { if (kv.utils.isEmptyVal(val)) { return true } var comparisonValue, type; if (options.typeAttr === undefined) { type = "text"; comparisonValue = options } else { type = options.typeAttr; comparisonValue = options.value } if (!isNaN(comparisonValue)) { type = "number" } var regex, valMatches, comparisonValueMatches; switch (type.toLowerCase()) { case "week": regex = /^(\d{4})-W(\d{2})$/; valMatches = val.match(regex); if (valMatches === null) { throw "Invalid value for " + validatorName + " attribute for week input.  Should look like " + "'2000-W33' http://www.w3.org/TR/html-markup/input.week.html#input.week.attrs.min" } comparisonValueMatches = comparisonValue.match(regex); if (!comparisonValueMatches) { return false } if (isMaxValidation) { return (valMatches[1] < comparisonValueMatches[1]) || ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2])) } else { return (valMatches[1] > comparisonValueMatches[1]) || ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2])) } break; case "month": regex = /^(\d{4})-(\d{2})$/; valMatches = val.match(regex); if (valMatches === null) { throw "Invalid value for " + validatorName + " attribute for month input.  Should look like " + "'2000-03' http://www.w3.org/TR/html-markup/input.month.html#input.month.attrs.min" } comparisonValueMatches = comparisonValue.match(regex); if (!comparisonValueMatches) { return false } if (isMaxValidation) { return ((valMatches[1] < comparisonValueMatches[1]) || ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] <= comparisonValueMatches[2]))) } else { return (valMatches[1] > comparisonValueMatches[1]) || ((valMatches[1] === comparisonValueMatches[1]) && (valMatches[2] >= comparisonValueMatches[2])) } break; case "number": case "range": if (isMaxValidation) { return (!isNaN(val) && parseFloat(val) <= parseFloat(comparisonValue)) } else { return (!isNaN(val) && parseFloat(val) >= parseFloat(comparisonValue)) } break; default: if (isMaxValidation) { return val <= comparisonValue } else { return val >= comparisonValue } } } } kv.rules['min'] = { validator: minMaxValidatorFactory("min"), message: 'Please enter a value greater than or equal to {0}.' }; kv.rules['max'] = { validator: minMaxValidatorFactory("max"), message: 'Please enter a value less than or equal to {0}.' }; kv.rules['minLength'] = { validator: function (val, minLength) { return kv.utils.isEmptyVal(val) || val.length >= minLength }, message: 'Please enter at least {0} characters.' }; kv.rules['maxLength'] = { validator: function (val, maxLength) { return kv.utils.isEmptyVal(val) || val.length <= maxLength }, message: 'Please enter no more than {0} characters.' }; kv.rules['pattern'] = { validator: function (val, regex) { return kv.utils.isEmptyVal(val) || val.toString().match(regex) !== null }, message: 'Please check this value.' }; kv.rules['step'] = { validator: function (val, step) { if (kv.utils.isEmptyVal(val) || step === 'any') { return true } var dif = (val * 100) % (step * 100); return Math.abs(dif) < 0.00001 || Math.abs(1 - dif) < 0.00001 }, message: 'The value must increment by {0}' }; kv.rules['email'] = { validator: function (val, validate) { if (!validate) { return true } return kv.utils.isEmptyVal(val) || (validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)) }, message: 'Please enter a proper email address' }; kv.rules['date'] = { validator: function (value, validate) { if (!validate) { return true } return kv.utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value))) }, message: 'Please enter a proper date' }; kv.rules['dateISO'] = { validator: function (value, validate) { if (!validate) { return true } return kv.utils.isEmptyVal(value) || (validate && /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/.test(value)) }, message: 'Please enter a proper date' }; kv.rules['number'] = { validator: function (value, validate) { if (!validate) { return true } return kv.utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value)) }, message: 'Please enter a number' }; kv.rules['digit'] = { validator: function (value, validate) { if (!validate) { return true } return kv.utils.isEmptyVal(value) || (validate && /^\d+$/.test(value)) }, message: 'Please enter a digit' }; kv.rules['phoneUS'] = { validator: function (phoneNumber, validate) { if (!validate) { return true } if (kv.utils.isEmptyVal(phoneNumber)) { return true } if (typeof (phoneNumber) !== 'string') { return false } phoneNumber = phoneNumber.replace(/\s+/g, ""); return validate && phoneNumber.length > 9 && phoneNumber.match(/^0?(13[0-9]|15[012356789]|18[0236789]|14[57])[0-9]{8}$/) }, message: 'Please specify a valid phone number' }; kv.rules['equal'] = { validator: function (val, params) { var otherValue = params; return val === kv.utils.getValue(otherValue) }, message: 'Values must equal' }; kv.rules['notEqual'] = { validator: function (val, params) { var otherValue = params; return val !== kv.utils.getValue(otherValue) }, message: 'Please choose another value.' }; kv.rules['unique'] = { validator: function (val, options) { var c = kv.utils.getValue(options.collection), external = kv.utils.getValue(options.externalValue), counter = 0; if (!val || !c) { return true } koUtils.arrayFilter(c, function (item) { if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) { counter++ } }); return counter < (!!external ? 1 : 2) }, message: 'Please make sure the value is unique.' }; (function () { kv.registerExtenders() }()); ko.bindingHandlers['validationCore'] = (function () { return { init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { var config = kv.utils.getConfigOptions(element); var observable = valueAccessor(); if (config.parseInputAttributes) { kv.utils.async(function () { kv.parseInputValidationAttributes(element, valueAccessor) }) } if (config.insertMessages && kv.utils.isValidatable(observable)) { var validationMessageElement = kv.insertValidationMessage(element); if (config.messageTemplate) { ko.renderTemplate(config.messageTemplate, { field: observable }, null, validationMessageElement, 'replaceNode') } else { ko.applyBindingsToNode(validationMessageElement, { validationMessage: observable }) } } if (config.writeInputAttributes && kv.utils.isValidatable(observable)) { kv.writeInputValidationAttributes(element, valueAccessor) } if (config.decorateInputElement && kv.utils.isValidatable(observable)) { ko.applyBindingsToNode(element, { validationElement: observable }) } } } }()); kv.makeBindingHandlerValidatable("value"); kv.makeBindingHandlerValidatable("checked"); ko.bindingHandlers['validationMessage'] = { update: function (element, valueAccessor) { var obsv = valueAccessor(), config = kv.utils.getConfigOptions(element), val = unwrap(obsv), msg = null, isModified = false, isValid = false; if (!obsv.isValid || !obsv.isModified) { throw new Error("Observable is not validatable") } isModified = obsv.isModified(); isValid = obsv.isValid(); var error = null; if (!config.messagesOnModified || isModified) { error = isValid ? null : obsv.error } var isVisible = !config.messagesOnModified || isModified ? !isValid : false; var isCurrentlyVisible = element.style.display !== "none"; if (config.allowHtmlMessages) { koUtils.setHtml(element, error) } else { ko.bindingHandlers.text.update(element, function () { return error }) } if (isCurrentlyVisible && !isVisible) { element.style.display = 'none' } else if (!isCurrentlyVisible && isVisible) { element.style.display = '' } } }; ko.bindingHandlers['validationElement'] = { update: function (element, valueAccessor, allBindingsAccessor) { var obsv = valueAccessor(), config = kv.utils.getConfigOptions(element), val = unwrap(obsv), msg = null, isModified = false, isValid = false; if (!obsv.isValid || !obsv.isModified) { throw new Error("Observable is not validatable") } isModified = obsv.isModified(); isValid = obsv.isValid(); var cssSettingsAccessor = function () { var css = {}; var shouldShow = ((!config.decorateElementOnModified || isModified) ? !isValid : false); css[config.errorElementClass] = shouldShow; return css }; ko.bindingHandlers.css.update(element, cssSettingsAccessor, allBindingsAccessor); if (!config.errorsAsTitle) { return } ko.bindingHandlers.attr.update(element, function () { var hasModification = !config.errorsAsTitleOnModified || isModified, title = kv.utils.getOriginalElementTitle(element); if (hasModification && !isValid) { return { title: obsv.error, 'data-orig-title': title } } else if (!hasModification || isValid) { return { title: title, 'data-orig-title': null } } }) } }; ko.bindingHandlers['validationOptions'] = (function () { return { init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) { var options = unwrap(valueAccessor()); if (options) { var newConfig = extend({}, kv.configuration); extend(newConfig, options); kv.utils.setDomData(element, newConfig) } } } }()); ko.extenders['validation'] = function (observable, rules) { forEach(kv.utils.isArray(rules) ? rules : [rules], function (rule) { kv.addAnonymousRule(observable, rule) }); return observable }; ko.extenders['validatable'] = function (observable, options) { if (!kv.utils.isObject(options)) { options = { enable: options } } if (!('enable' in options)) { options.enable = true } if (options.enable && !kv.utils.isValidatable(observable)) { var config = kv.configuration.validate || {}; var validationOptions = { throttleEvaluation: options.throttle || config.throttle }; observable.error = ko.observable(null); observable.rules = ko.observableArray(); observable.isValidating = ko.observable(false); observable.__valid__ = ko.observable(true); observable.isModified = ko.observable(false); observable.isValid = ko.computed(observable.__valid__); observable.setError = function (error) { observable.error(error); observable.__valid__(false) }; observable.clearError = function () { observable.error(null); observable.__valid__(true); return observable }; var h_change = observable.subscribe(function () { observable.isModified(true) }); var h_obsValidationTrigger = ko.computed(extend({ read: function () { var obs = observable(), ruleContexts = observable.rules(); kv.validateObservable(observable); return true } }, validationOptions)); extend(h_obsValidationTrigger, validationOptions); observable._disposeValidation = function () { observable.isValid.dispose(); observable.rules.removeAll(); if (observable.isModified.getSubscriptionsCount() > 0) { observable.isModified._subscriptions['change'] = [] } if (observable.isValidating.getSubscriptionsCount() > 0) { observable.isValidating._subscriptions['change'] = [] } if (observable.__valid__.getSubscriptionsCount() > 0) { observable.__valid__._subscriptions['change'] = [] } h_change.dispose(); h_obsValidationTrigger.dispose(); delete observable['rules']; delete observable['error']; delete observable['isValid']; delete observable['isValidating']; delete observable['__valid__']; delete observable['isModified'] } } else if (options.enable === false && observable._disposeValidation) { observable._disposeValidation() } return observable }; function validateSync(observable, rule, ctx) { if (!rule.validator(observable(), (ctx.params === undefined ? true : unwrap(ctx.params)))) { observable.setError(kv.formatMessage(ctx.message || rule.message, unwrap(ctx.params), observable)); return false } else { return true } } function validateAsync(observable, rule, ctx) { observable.isValidating(true); var callBack = function (valObj) { var isValid = false, msg = ''; if (!observable.__valid__()) { observable.isValidating(false); return; } if (valObj['message']) { isValid = valObj.isValid; msg = valObj.message } else { isValid = valObj } if (!isValid) { observable.error(kv.formatMessage(msg || ctx.message || rule.message, unwrap(ctx.params), observable)); observable.__valid__(isValid) } observable.isValidating(false) }; rule.validator(observable(), unwrap(ctx.params || true), callBack) } kv.validateObservable = function (observable) { var i = 0, rule, ctx, ruleContexts = observable.rules(), len = ruleContexts.length; for (; i < len; i++) { ctx = ruleContexts[i]; if (ctx.condition && !ctx.condition()) { continue } rule = ctx.rule ? kv.rules[ctx.rule] : ctx; if (rule['async'] || ctx['async']) { validateAsync(observable, rule, ctx) } else { if (!validateSync(observable, rule, ctx)) { return false; } } } observable.clearError(); return true }; kv.localize = function (msgTranslations) { var msg, rule; for (rule in msgTranslations) { if (kv.rules.hasOwnProperty(rule)) { kv.rules[rule].message = msgTranslations[rule] } } }; ko.applyBindingsWithValidation = function (viewModel, rootNode, options) { var len = arguments.length, node, config; if (len > 2) { node = rootNode; config = options } else if (len < 2) { node = document.body } else { if (arguments[1].nodeType) { node = rootNode } else { config = arguments[1] } } kv.init(); if (config) { kv.utils.setDomData(node, config) } ko.applyBindings(viewModel, rootNode) }; var origApplyBindings = ko.applyBindings; ko.applyBindings = function (viewModel, rootNode) { kv.init(); origApplyBindings(viewModel, rootNode) }; ko.validatedObservable = function (initialValue) { if (!kv.utils.isObject(initialValue)) { return ko.observable(initialValue).extend({ validatable: true }) } var obsv = ko.observable(initialValue); obsv.isValid = ko.observable(); obsv.errors = kv.group(initialValue); obsv.errors.subscribe(function (errors) { obsv.isValid(errors.length === 0) }); return obsv }; }));